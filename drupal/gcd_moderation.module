<?php

/**
 * @file
 * Enables the moderation interface and functionality.
 */

/**
 * Implementation of hook_help().
 */
function gcd_moderation_help($section) {
  switch ($section) {
    case 'admin/gcd/moderation':
      return '<p>'. t("If there are multiple revisions to a piece of content, it is only listed below once - <strong>approving or deleting that entry will affect ALL pending revisions from any user</strong>. You can approve or delete specific revisions on the entry's primary revisions disply. If you delete a newly-created piece of content, it is your responsibility to revise any data that refers to that content (such as content referring to a just-deleted creator).") .'</p>';
  }
}

/**
 * Implementation of hook_menu().
 */
function gcd_moderation_menu($may_cache) {
  $items = array();

  if ($may_cache) {
    $items[] = array(
      'access'             => user_access('moderate gcd data'),
      'callback'           => 'gcd_moderation_overview',
      'description'        => t('Moderate new content or existing revisions.'),
      'path'               => 'admin/gcd/moderation',
      'title'              => t('Moderate content'),
    );
  }

  return $items;
}

/**
 * Moderate new content or existing revisions.
 *
 * This is largely a combined wrapper around the two different admin screens
 * that modr8.module and revision_moderation.module give us. This gives us
 * a more centralized view, and stronger control of logging.
 *
 * @param $nid
 *   Optional; the node ID to perform the $type of action on.
 * @param $type
 *   Optional; if $nid passed, required. The type of action to perform.
 *   Currently one of "approve" or "delete".
 */
function gcd_moderation_overview($nid = NULL, $type = NULL) {
  $output = NULL;

  // if we've no actions, show a list of pending.
  if ((!$nid && !$type) || ($nid && !$type)) {
    $rows = array();
    $headers = array(
      array('data' => t('Status'),     'field' => 'n.moderate'),
      array('data' => t('Type'),       'field' => 'n.type'),
      array('data' => t('Title'),      'field' => 'n.title'),
      array('data' => t('Who'),        'field' => 'u.name'),
      array('data' => t('When'),       'field' => 'r.timestamp', 'sort' => 'desc'),
      array('data' => t('Operations'), 'colspan' => 2),
    );

    // get a list of all content either in moderation or with a newer revision than what is published.
    $sql = "SELECT n.nid, r.vid, COUNT(r.vid) AS r_count, n.moderate, n.type, r.title, r.timestamp, u.uid, u.name FROM {node} n INNER JOIN {node_revisions} r ON (n.nid = r.nid) INNER JOIN {users} u ON (r.uid = u.uid) WHERE (r.vid > n.vid OR n.moderate = 1) GROUP BY n.nid";
    $results = pager_query($sql . tablesort_sql($headers), 50);

    while ($result = db_fetch_object($results)) {
      $r_count = format_plural($result->r_count, 'Revision', 'Revisions (@count)');

      $rows[] = array(
        $result->moderate ? t('New') : t('@r_count', array('@r_count' => $r_count)),
        check_plain($result->type), // if space becomes a premium, we can delete this, I'd think.
        l($result->title, $result->moderate ? 'node/'. $result->nid : 'node/'. $result->nid .'/revisions'),
        theme('username', $result), // whodunit, eh? LAST whodunit for revisions though, not all of 'em.
        format_date($result->timestamp, 'small'),
        l(t('approve'), 'admin/gcd/moderation/'. $result->nid .'/approve'),
        l(t('delete'), 'admin/gcd/moderation/'. $result->nid .'/delete')
      );
    }

    if (count($rows) == 0) { // this should never really happen once the site is public.
      $rows[] = array(array('colspan' => 6, 'data' => t('There are no items to be moderated.')));
    }

    $output .= theme('table', $headers, $rows);
    $output .= theme('pager', NULL, 50, 0);
  }

  // we've got an action. what kind of wooORk? TeAaAmWoOOrk!
  if (is_numeric($nid) && in_array($type, array('approve', 'delete'))) {
    // we'll only fetch a result if the node has a greater revision pending, or if it's in moderation.
    $result = db_fetch_object(db_query("SELECT n.nid, n.vid AS published_vid, r.vid, n.moderate, n.type, r.title, u.name FROM {node} n INNER JOIN {node_revisions} r ON (n.nid = r.nid) INNER JOIN {users} u ON (r.uid = u.uid) WHERE (r.vid > n.vid OR n.moderate = 1) AND n.nid = %d ORDER BY r.timestamp DESC", $nid));

    // we're approving a new piece of content.
    if ($type == 'approve' && $result->nid && $result->moderate) {
      db_query('UPDATE {node} SET moderate = 0 WHERE nid = %d', $result->nid);
      drupal_set_message(t('The %type entitled %title has been approved.', array('%type' => $result->type, '%title' => $result->title)));
      watchdog('gcd moderation', t('@type: approved %title.', array('@type' => $result->type, '%title' => $result->title)), WATCHDOG_NOTICE, l(t('view'), "node/$result->nid"));
      cache_clear_all(); // let any of our cached content recreate based on this decision.
    }
    // we're approving all pending revisions for this content.
    elseif ($type == 'approve' && $result->nid && !$result->moderate) {
      db_query("UPDATE {node} SET vid = %d, title = '%s' WHERE nid = %d", $result->vid, $result->title, $result->nid);
      drupal_set_message(t('Revisions for %type entitled %title have been approved.', array('%type' => $result->type, '%title' => $result->title)));
      watchdog('gcd moderation', t('@type: approved pending revisions for %title.', array('@type' => $result->type, '%title' => $result->title)), WATCHDOG_NOTICE, l(t('view'), "node/$result->nid"));
      cache_clear_all(); // let any of our cached content recreate based on this decision.
    }
    // we're deleting a new piece of content.
    elseif ($type == 'delete' && $result->nid && $result->moderate) {
      node_delete($result->nid); // get rid of this node entirely. doesn't affect anything that refers to this node.
      drupal_set_message(t('The %type entitled %title has been deleted.', array('%type' => $result->type, '%title' => $result->title)));
      watchdog('gcd moderation', t('@type: deleted %title.', array('@type' => $result->type, '%title' => $result->title)));
    }
    // we're deleting all pending revisions for this content.
    elseif ($type == 'delete' && $result->nid && !$result->moderate) {
      $revision_results = db_query('SELECT r.vid FROM {node_revisions} WHERE r.nid = %d AND r.vid > %d', $result->nid, $result->published_vid);
      while ($revision_result = db_fetch_object($revision_results)) {
        db_query("DELETE FROM {node_revisions} WHERE nid = %d AND vid = %d", $result->nid, $revision_result->vid);
        node_invoke_nodeapi($node, 'delete revision'); // let all our other modules handle this deletion natively.
      } // and send out our standard happy verbiage extolling the virtues of how responsive we are to your demands.
      drupal_set_message(t('Revisions for %type entitled %title has been deleted.', array('%type' => $result->type, '%title' => $result->title)));
      watchdog('gcd moderation', t('@type: deleted pending revisions for %title.', array('@type' => $result->type, '%title' => $result->title)));
    }

    drupal_goto('admin/gcd/moderation');
  }

  return $output;
}

/**
 * Implementation of hook_nodeapi().
 *
 * For moderation, we're primarily twiddling either the node.moderate column
 * (for content that is being, or has just been, created) or determine if we
 * should load an existing revision, or reset the node to last published.
 */
function gcd_moderation_nodeapi(&$node, $op, $teaser = NULL, $page = NULL) {
  $node_types = gcd_node_info(); // all the GCD node types.

  switch ($op) {
    case 'load':
      return db_fetch_array(db_query('SELECT n.moderate FROM {node} n WHERE n.nid = %d', $node->nid));

    case 'prepare':
      if ($node->nid && isset($node_types[$node->type])) {
        global $user; // do they have a revision pending?

        // If user has a pending revision for this node, load that version for editing.
        $revision_vid = db_result(db_query("SELECT r.vid FROM {node} n INNER JOIN {node_revisions} r ON (n.nid = r.nid) WHERE r.vid > n.vid AND n.nid = %d AND n.uid = %d ORDER BY r.vid DESC", $node->nid, $user->uid));
        if ($revision_vid) { // yep, this user has a revision pending approval, so we'll load that one in for the new base.
          drupal_set_message(t('Editing your latest revision, which is still pending moderation.'));
          $node = node_load($node->nid, $revision_vid); // replace the current edit with this revision.
        }
      }

      break;

    case 'submit':
      // whee, a new node. is it one of our GCD node types?
      if (!isset($node->nid) && isset($node_types[$node->type])) {
        $node->moderate = 1; // yeppers, must be.
      }

      // an existing node: stick the currently published node in original_node. this
      // is necessary due to our 'prepare' above, which loads in the user's last edited
      // and still-in-moderation revision. we need original_node to tweak the standard
      // Drupal 'update' (below) with the currently published version, not the revision
      // still in moderation that the user is editing.
      if (isset($node->nid) && isset($node_types[$node->type])) {
        $current_vid = db_result(db_query('SELECT vid FROM {node} WHERE nid = %d', $node->nid));
        $node->original_node = node_load($node->nid, $current_vid);
      }

      break;

    case 'view':
      if ($node->moderate && empty($node->in_preview) && !$teaser) {
        drupal_set_message(t("This content is in the moderation queue and won't be listed until it has been approved."), 'error');
      }

      break;

    case 'insert':
      db_query('UPDATE {node} SET moderate = %d WHERE nid = %d', $node->moderate, $node->nid);
      break;

    case 'update':
      db_query('UPDATE {node} SET moderate = %d WHERE nid = %d', $node->moderate, $node->nid);

      if (isset($node->original_node)) { // update to the latest moderated revision (see 'prepare' and 'submit' above).
        db_query("UPDATE {node} SET vid = %d, title = '%s', status = %d, moderate = %d WHERE nid = %d", $node->original_node->vid, $node->original_node->title, $node->original_node->status, $node->original_node->moderate, $node->nid);
        drupal_set_message(t('Your changes have been submitted for moderation.'));
      }

      break;
  }
}

/**
 * Implementation of hook_db_rewrite_sql().
 */
function gcd_moderation_db_rewrite_sql($query, $primary_table, $primary_field, $args) {
  if ($primary_field == 'nid') {
    // don't show nodes still in moderation in lists unless we're either an admin,
    // one of our moderators (i.e. editors), or if it's the creator of the content.
    if (!(user_access('administer nodes') || user_access('moderate gcd data'))) {
      global $user; $return = array(); // suck in our user and prepare our SQL modifications.
      $return['join'] = ($primary_table != 'n') ? "LEFT JOIN {node} n ON $primary_table.nid = n.nid" : '';
      $return['where'] = ($user->uid == 0) ? "(n.moderate != 1)" : "(n.moderate != 1 OR n.uid = ". (int)$user->uid .")";
      return $return; // this will modify all node related SQL queries to respect our moderation setting.
    }
  }
}

/**
 * Implementation of hook_form_alter().
 */
function gcd_moderation_form_alter($form_id, &$form) {
  $node = isset($form['#node']) ? $form['#node'] : NULL;
  $node_types = gcd_node_info(); // all the GCD node types.

  // tweaks for all our node types.
  switch ($form_id) {
    case isset($node_types[str_replace('_node_form', '', $form_id)]):

      // for new submissions, we require moderation, but no revisions.
      // revisions only occur after the new submission is moderated.
      if (!$node->nid || (isset($node->moderate) && $node->moderate)) {
        $form['log']['#type'] = 'value';
        $form['options']['revision']['#type'] = 'value';
        $form['options']['revision']['#value'] = 0;
      }

      // for edits of moderated content, revisions are compulsory.
      if (isset($node->moderate) && !$node->moderate) {
        $form['additional']['log'] = $form['log'];
        $form['additional']['log']['#required'] = TRUE;
        $form['additional']['log']['#type'] = 'textarea';
        $form['options']['revision']['#value'] = 1;
        $form['options']['revision']['#type'] = 'value';
        unset($form['log']);
      }

      break;
  }
}
